# Search V2 자동 테스트 명세

이 문서는 Search V2 컴포넌트의 자동화 테스트 구현 명세입니다. Jest + @testing-library/react + @testing-library/user-event를 사용하여 접근성과 핵심 기능을 자동 검증합니다.

## 테스트 환경 설정

### 필수 의존성
```json
{
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.4.3",
    "@testing-library/jest-dom": "^6.1.0",
    "jest-axe": "^8.0.0",
    "jsdom": "^22.1.0"
  }
}
```

### Jest 설정
```javascript
// jest.config.js
export default {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1'
  }
}
```

### 테스트 실행 명령
```bash
# 전체 테스트 실행
pnpm test
# 또는
npm run test

# 접근성 테스트만 실행
pnpm test a11y.smoke
```

## 테스트 케이스 명세

### 1. Combobox ARIA 테스트 (APG 기준)

#### 1.1 기본 ARIA 속성 검증
```typescript
describe('Combobox ARIA Attributes', () => {
  test('should have required ARIA attributes', () => {
    // role="combobox" 존재
    // aria-controls 설정 (listbox ID 참조)
    // aria-expanded 초기값 false
    // aria-autocomplete="list" 설정
  })
})
```

#### 1.2 동적 ARIA 상태 검증
```typescript
describe('Combobox Dynamic ARIA', () => {
  test('should update aria-activedescendant on keyboard navigation', () => {
    // 사용자 입력으로 제안 목록 표시
    // ArrowDown 키로 첫 번째 옵션 활성화
    // aria-activedescendant가 활성 옵션 ID로 갱신되는지 검증
    // ArrowDown 키로 두 번째 옵션 활성화
    // aria-activedescendant가 두 번째 옵션 ID로 갱신되는지 검증
  })
  
  test('should update aria-expanded on popup state change', () => {
    // 초기 상태: aria-expanded="false"
    // 입력 후: aria-expanded="true"
    // Escape 후: aria-expanded="false"
  })
})
```

#### 1.3 키보드 네비게이션 테스트
```typescript
describe('Combobox Keyboard Navigation', () => {
  test('should navigate options with arrow keys', () => {
    // ArrowDown: 다음 옵션으로 이동
    // ArrowUp: 이전 옵션으로 이동
    // 마지막에서 첫 번째로 순환
    // 첫 번째에서 마지막으로 순환
  })
  
  test('should select option with Enter key', () => {
    // Enter 키로 선택된 옵션을 입력창에 복사
    // 제안 목록 자동 닫힘
    // 입력창 포커스 유지
  })
})
```

**검증 실패 시 출력**:
```
❌ Combobox ARIA 테스트 실패
원인: aria-activedescendant 속성이 갱신되지 않음
재현 절차:
1. 검색창에 "블로그" 입력
2. ArrowDown 키 누르기
3. aria-activedescendant 값 확인
예상: "hub-suggest-listbox-opt-0"
실제: undefined
```

### 2. Dialog ARIA 테스트 (MDN/APG 기준)

#### 2.1 기본 Dialog 속성 검증
```typescript
describe('Dialog ARIA Attributes', () => {
  test('should have required dialog attributes', () => {
    // role="dialog" 존재
    // aria-modal="true" 설정
    // aria-labelledby 설정 (제목 ID 참조)
    // aria-describedby 설정 (설명 ID 참조)
  })
})
```

#### 2.2 포커스 관리 테스트
```typescript
describe('Dialog Focus Management', () => {
  test('should move focus to dialog when opened', () => {
    // 카드 클릭 전 활성 요소 기록
    // 카드 클릭으로 사이드시트 열기
    // 닫기 버튼으로 포커스 이동 검증
  })
  
  test('should return focus to trigger when closed', () => {
    // 사이드시트 열기
    // 닫기 버튼 클릭
    // 원래 트리거 요소로 포커스 복귀 검증
  })
})
```

**검증 실패 시 출력**:
```
❌ Dialog 포커스 관리 테스트 실패
원인: 사이드시트 닫힘 시 포커스가 트리거로 복귀하지 않음
재현 절차:
1. "블로그 글 초안 만들기" 카드 클릭
2. 사이드시트 열림 확인
3. 닫기 버튼 클릭
4. 포커스 위치 확인
예상: 카드 버튼에 포커스
실제: document.body에 포커스
```

### 3. Focus Trap 테스트 (a11y-collective/UXPin 기준)

#### 3.1 포커스 순환 테스트
```typescript
describe('Focus Trap Behavior', () => {
  test('should trap focus within dialog', () => {
    // 사이드시트 열기
    // Tab 키로 모든 포커스 가능 요소 순환
    // 마지막 요소에서 첫 번째 요소로 순환 검증
  })
  
  test('should handle Shift+Tab reverse navigation', () => {
    // 사이드시트 열기
    // Shift+Tab으로 역순 탐색
    // 첫 번째 요소에서 마지막 요소로 순환 검증
  })
})
```

#### 3.2 탈출 조건 테스트
```typescript
describe('Focus Trap Escape', () => {
  test('should release trap on Escape key', () => {
    // 사이드시트 열기
    // Escape 키 누르기
    // 포커스 트랩 해제 및 시트 닫힘 검증
  })
  
  test('should prevent focus outside dialog', () => {
    // 사이드시트 열기
    // 시트 외부 요소로 강제 포커스 시도
    // 포커스가 시트 내부로 다시 이동하는지 검증
  })
})
```

**검증 실패 시 출력**:
```
❌ 포커스 트랩 테스트 실패
원인: Tab 키로 시트 외부로 포커스 이동됨
재현 절차:
1. 사이드시트 열기
2. 마지막 버튼에서 Tab 키 누르기
3. 포커스 위치 확인
예상: 첫 번째 요소 (닫기 버튼)에 포커스
실제: 페이지 외부 요소에 포커스
```

### 4. Side Sheet 타입 테스트 (Material Design 기준)

#### 4.1 반응형 동작 테스트
```typescript
describe('Side Sheet Responsive Behavior', () => {
  test('should show fixed side sheet on desktop', () => {
    // 1024px 이상 뷰포트 설정
    // 사이드시트 열기
    // 고정 너비 및 우측 배치 검증
    // transform: translateX(0) 스타일 검증
  })
  
  test('should show modal sheet on mobile', () => {
    // 768px 이하 뷰포트 설정
    // 사이드시트 열기
    // 전체 화면 모달 전환 검증
    // transform: translateY(0) 스타일 검증
  })
})
```

#### 4.2 스타일 및 레이아웃 테스트
```typescript
describe('Side Sheet Layout', () => {
  test('should have correct desktop styles', () => {
    // 너비: min(520px, 92vw)
    // 위치: 우측 고정
    // z-index: 1060
    // 배경 스크림 z-index: 1040
  })
  
  test('should have correct mobile styles', () => {
    // 너비: 100vw
    // 높이: 100dvh
    // 상단 모서리 둥글게 처리
    // 하단에서 위로 슬라이드
  })
})
```

**검증 실패 시 출력**:
```
❌ 사이드시트 반응형 테스트 실패
원인: 모바일에서 모달 전환이 작동하지 않음
재현 절차:
1. 뷰포트를 768px로 설정
2. 카드 클릭으로 사이드시트 열기
3. CSS 클래스 및 스타일 확인
예상: 전체 화면 모달 (width: 100vw)
실제: 고정 사이드시트 (width: 520px)
```

### 5. 로딩 UI 테스트 (NN/g 기준)

#### 5.1 스켈레톤 UI 테스트
```typescript
describe('Skeleton Loading UI', () => {
  test('should show skeleton on initial load', () => {
    // 컴포넌트 마운트 시 loading=true 상태
    // 스켈레톤 요소 존재 검증
    // aria-hidden="true" 설정 검증
  })
  
  test('should replace skeleton with content', () => {
    // loading=false로 상태 변경
    // 스켈레톤 요소 제거 검증
    // 실제 콘텐츠 표시 검증
  })
})
```

#### 5.2 스피너 UI 테스트
```typescript
describe('Spinner Loading UI', () => {
  test('should show spinner during search', () => {
    // 검색 중 상태 시뮬레이션
    // 스피너 요소 존재 검증
    // aria-label="로딩 중" 검증
  })
  
  test('should hide spinner after search completion', () => {
    // 검색 완료 상태 시뮬레이션
    // 스피너 요소 제거 검증
  })
})
```

**검증 실패 시 출력**:
```
❌ 로딩 UI 테스트 실패
원인: 스켈레톤 UI에 접근성 라벨이 누락됨
재현 절차:
1. 컴포넌트 로딩 상태로 렌더링
2. 스켈레톤 요소의 aria-hidden 속성 확인
예상: aria-hidden="true"
실제: 속성 없음
```

## 테스트 유틸리티 함수

### focusTrapAssert 헬퍼
```typescript
function focusTrapAssert(container: HTMLElement) {
  const focusableElements = container.querySelectorAll(
    'a, button, input, textarea, select, [tabindex]:not([tabindex="-1"])'
  )
  
  // 포커스 가능한 요소들이 올바른 순서로 순환하는지 검증
  // Tab/Shift+Tab 동작 시뮬레이션
  // 경계 조건 (첫 번째 ↔ 마지막) 검증
}
```

### pressKeys 헬퍼
```typescript
async function pressKeys(user: UserEvent, keys: string[]) {
  for (const key of keys) {
    await user.keyboard(`{${key}}`)
    // 각 키 입력 사이에 적절한 지연 시간
    await new Promise(resolve => setTimeout(resolve, 50))
  }
}
```

### mockIntersectionObserver 헬퍼
```typescript
function mockIntersectionObserver() {
  global.IntersectionObserver = jest.fn().mockImplementation(() => ({
    observe: jest.fn(),
    unobserve: jest.fn(),
    disconnect: jest.fn(),
  }))
}
```

## 테스트 실행 및 보고

### CI/CD 통합
```yaml
# .github/workflows/test.yml
name: Accessibility Tests
on: [push, pull_request]
jobs:
  a11y-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: pnpm install
      - run: pnpm test:a11y
      - uses: codecov/codecov-action@v3
```

### 테스트 커버리지
- **컴포넌트 커버리지**: 95% 이상
- **접근성 규칙 커버리지**: WCAG 2.1 AA 기준 100%
- **키보드 네비게이션**: 모든 상호작용 경로 100%

### 성능 기준
- **테스트 실행 시간**: < 30초
- **개별 테스트**: < 2초
- **메모리 사용량**: < 512MB

## 실패 시 디버깅 가이드

### 공통 문제 해결
1. **ARIA 속성 누락**: React DevTools로 속성 확인
2. **포커스 이동 실패**: `document.activeElement` 로깅
3. **키보드 이벤트 무시**: 이벤트 리스너 등록 확인
4. **CSS 스타일 미적용**: 테스트 환경에서 CSS 로드 확인

### 로그 활성화
```typescript
// 테스트에서 디버깅 로그 활성화
process.env.DEBUG_FOCUS = 'true'
process.env.DEBUG_ARIA = 'true'
```

---

> 모든 테스트는 실제 사용자 시나리오를 기반으로 하며, 접근성 표준 준수를 최우선으로 합니다.